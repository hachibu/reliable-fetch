{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/index.ts", "../src/fetch/fetchChaos.ts", "../src/fetch/fetchTimeout.ts", "../src/fetch/fetchHedge.ts", "../src/fetch/fetchRetry.ts"],
  "sourcesContent": ["import {\n    ChaosConfig,\n    HedgeConfig,\n    ReliableRequestInfo,\n    ReliableRequestInit,\n    RetryConfig,\n    TimeoutConfig,\n} from './types'\nimport { fetchChaos, fetchHedge, fetchRetry, fetchTimeout } from './fetch'\nimport EventEmitter from 'events'\nimport { EventName, EventListenerFunction } from './types'\n\nexport class ReliableFetch {\n    constructor(\n        private input: ReliableRequestInfo,\n        private init: ReliableRequestInit = {}\n    ) {\n        this.init.eventEmitter = new EventEmitter()\n    }\n\n    /**\n     * Listen for a specific lifecycle event by event name.\n     *\n     * @param {EventName} eventName - unique identifier for a lifecycle event\n     * @param {EventListenerFunction} listener - callback function for when the lifecycle event is emitted\n     */\n    on(eventName: EventName, listener: EventListenerFunction): ReliableFetch {\n        const { eventEmitter } = this.init\n        if (eventEmitter) {\n            eventEmitter.on(eventName, listener)\n        }\n        return this\n    }\n\n    /**\n     * The request will be aborted with an `AbortError` if it does not settle\n     * within the configured timeout.\n     *\n     * @param {TimeoutConfig} config - timeout config\n     * @param {number} config.timeout - milliseconds (default: 10000)\n     */\n    timeout(config?: Partial<TimeoutConfig>): Promise<Response> {\n        return fetchTimeout(this.input, { ...this.init, ...config })\n    }\n\n    /**\n     * The initial request will be aborted if it does not settle within the\n     * configured timeout and hedged with another request (e.g. set\n     * `config.timeout` to the 95th percentile response time to hedge 5% of\n     * requests).\n     *\n     * @param {HedgeConfig} config - hedge config\n     * @param {number} config.timeout - milliseconds (default: 10000)\n     *\n     * @see https://courses.cs.duke.edu//cps296.4/fall13/838-CloudPapers/dean_longtail.pdf\n     */\n    hedge(config?: Partial<HedgeConfig>): Promise<Response> {\n        return fetchHedge(this.input, { ...this.init, ...config })\n    }\n\n    /**\n     * The request will behave chaotically (e.g. down, slow) at the configured\n     * rate (e.g. set `config.rate` to `0.1` to impact ~10% of requests).\n     *\n     * @param {ChaosConfig} config - chaos config\n     * @param {number} config.rate - number between 0 and 1 representing the percentage of fetch calls to fail (default: 1)\n     * @param {ChaosDownConfig} config.down - failure config\n     * @param {number} config.down.status - status code to fail with (default: 500)\n     * @param {ChaosSlowConfig} config.slow - latency config\n     * @param {number} config.slow.delay - latency delay in milliseconds (default: 0)\n     * @param {Jitter} config.slow.jitter - latency jitter (default: none)\n     */\n    chaos(config?: Partial<ChaosConfig>): Promise<Response> {\n        return fetchChaos(this.input, { ...this.init, ...config })\n    }\n\n    /**\n     * The request will be retried based on the config.\n     *\n     * @param {RetryConfig} config - retry config\n     * @param {number} config.attempts - number of times to attempt (default: 1)\n     * @param {number} config.maxAttempts - maximum number of times to attempt (default: 10)\n     * @param {number} config.delay - delay between attempts in milliseconds (default: 100)\n     * @param {number} config.maxDelay - maximum delay between attempts in milliseconds (default: 10000)\n     * @param {Backoff} config.backoff - delay backoff (default: constant)\n     * @param {Jitter} config.jitter - delay jitter (default: none)\n     *\n     * @see https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n     */\n    retry(config?: Partial<RetryConfig>): Promise<Response> {\n        return fetchRetry(this.input, { ...this.init, ...config })\n    }\n}\n\nconst reliableFetch = (\n    url: ReliableRequestInfo,\n    init?: ReliableRequestInit\n): ReliableFetch => new ReliableFetch(url, init)\n\nexport default reliableFetch\nexport * from './fetch'\nexport * from './types'\n", "import crypto from 'crypto'\nimport { Backoff, Jitter } from '../types'\n\nexport const randomNumber = (): number => {\n    const max = 10 ** 10\n    return crypto.randomInt(0, max) / max\n}\n\nexport const randomNumberBetween = (min: number, max: number): number => {\n    return randomNumber() * (max - min) + min\n}\n\nexport const setTimeoutWithCancel = (\n    callback: VoidFunction,\n    ms?: number\n): { id: NodeJS.Timeout; cancel: VoidFunction } => {\n    const id = setTimeout(callback, ms)\n    const cancel = () => clearTimeout(id)\n\n    return {\n        id,\n        cancel,\n    }\n}\n\nexport const delayWithBackoff = (\n    delay: number,\n    attempt: number,\n    backoff: Backoff\n): number => {\n    switch (backoff) {\n        case 'exponential':\n            delay *= Math.pow(2, attempt)\n            break\n    }\n    return delay\n}\n\nexport const delayWithJitter = (delay: number, jitter: Jitter): number => {\n    switch (jitter) {\n        case 'full':\n            delay += randomNumberBetween(0, delay)\n            break\n        case 'equal':\n            delay += delay / 2 + randomNumberBetween(0, delay / 2)\n            break\n        case 'decorrelated':\n            delay += randomNumberBetween(delay, delay * 3)\n            break\n    }\n    return delay\n}\n", "import { ChaosConfig, ReliableFetchFunction } from '../types'\nimport { delayWithJitter, randomNumber } from '../utils'\nimport { setTimeout } from 'timers/promises'\n\nconst fetchChaos: ReliableFetchFunction = async (input, init) => {\n    const config: ChaosConfig = {\n        rate: 1 - (init?.rate ?? 0),\n        down: {\n            status: init?.down?.status ?? 500,\n        },\n        slow: {\n            delay: init?.slow?.delay ?? 0,\n            jitter: init?.slow?.jitter ?? 'none',\n        },\n    }\n    const downEnabled = !!init?.down\n    const slowEnabled = !!init?.slow\n\n    if (config.rate < 0 || config.rate > 1) {\n        throw new RangeError('rate: should be between 0 and 1')\n    }\n\n    if (downEnabled && randomNumber() > config.rate) {\n        const status = config.down.status\n        init?.eventEmitter?.emit('chaos:down', status)\n        return new Response(null, { status })\n    }\n\n    if (slowEnabled && randomNumber() > config.rate) {\n        const delay = delayWithJitter(config.slow.delay, config.slow.jitter)\n        await setTimeout(delay)\n        init?.eventEmitter?.emit('chaos:slow', delay)\n    }\n\n    return fetch(input, init)\n}\n\nexport default fetchChaos\n", "import { ReliableFetchFunction, TimeoutConfig } from '../types'\nimport { setTimeoutWithCancel } from '../utils'\n\nconst fetchTimeout: ReliableFetchFunction = async (input, init) => {\n    const config: TimeoutConfig = {\n        timeout: init?.timeout ?? 10000,\n    }\n    const controller = new AbortController()\n    const { cancel } = setTimeoutWithCancel(() => {\n        controller.abort()\n        init?.eventEmitter?.emit('timeout')\n    }, config.timeout)\n\n    return fetch(input, { ...init, signal: controller.signal }).finally(cancel)\n}\n\nexport default fetchTimeout\n", "import { HedgeConfig, ReliableFetchFunction } from '../types'\nimport fetchTimeout from './fetchTimeout'\n\nconst fetchHedge: ReliableFetchFunction = async (input, init) => {\n    const config: HedgeConfig = {\n        timeout: init?.timeout ?? 10000,\n    }\n    let response: Response\n\n    try {\n        response = await fetchTimeout(input, { ...init, ...config })\n    } catch (error) {\n        if (error instanceof Error) {\n            if (error.name !== 'AbortError') {\n                throw error\n            }\n        }\n        init?.eventEmitter?.emit('hedge')\n        response = await fetch(input, init)\n    }\n\n    return response\n}\n\nexport default fetchHedge\n", "import { ReliableFetchFunction, RetryConfig } from '../types'\nimport { setTimeout } from 'timers/promises'\nimport { delayWithBackoff, delayWithJitter } from '../utils'\n\nconst fetchRetry: ReliableFetchFunction = async (input, init) => {\n    const config: RetryConfig = {\n        delay: init?.delay ?? 100,\n        maxDelay: init?.maxDelay ?? 10000,\n        attempts: init?.attempts ?? 1,\n        maxAttempts: init?.maxAttempts ?? 10,\n        backoff: init?.backoff ?? 'constant',\n        jitter: init?.jitter ?? 'none',\n    }\n    let error\n\n    try {\n        return await fetch(input, init)\n    } catch (e) {\n        error = e\n    }\n\n    const attempts = Math.min(config.attempts, config.maxAttempts)\n\n    for (let attempt = 1; attempt <= attempts; attempt++) {\n        let delay = config.delay\n\n        delay = delayWithBackoff(delay, attempt, config.backoff)\n        delay = delayWithJitter(delay, config.jitter)\n        delay = Math.min(delay, config.maxDelay)\n\n        config.delay = delay\n\n        await setTimeout(delay)\n\n        init?.eventEmitter?.emit('retry', attempt, delay)\n        try {\n            return await fetch(input, init)\n        } catch (e) {\n            error = e\n        }\n    }\n\n    throw error\n}\n\nexport default fetchRetry\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "ReliableFetch", "src_default", "fetchChaos_default", "fetchHedge_default", "fetchRetry_default", "fetchTimeout_default", "__toCommonJS", "import_crypto", "randomNumber", "crypto", "randomNumberBetween", "min", "max", "setTimeoutWithCancel", "callback", "ms", "id", "delayWithBackoff", "delay", "attempt", "backoff", "delayWithJitter", "jitter", "import_promises", "fetchChaos", "input", "init", "config", "downEnabled", "slowEnabled", "randomNumber", "status", "delay", "delayWithJitter", "fetchChaos_default", "fetchTimeout", "input", "init", "config", "controller", "cancel", "setTimeoutWithCancel", "fetchTimeout_default", "fetchHedge", "input", "init", "config", "response", "fetchTimeout_default", "error", "fetchHedge_default", "import_promises", "fetchRetry", "input", "init", "config", "error", "e", "attempts", "attempt", "delay", "delayWithBackoff", "delayWithJitter", "fetchRetry_default", "import_events", "ReliableFetch", "input", "init", "EventEmitter", "eventName", "listener", "eventEmitter", "config", "fetchTimeout_default", "fetchHedge_default", "fetchChaos_default", "fetchRetry_default", "reliableFetch", "url", "src_default"]
}
