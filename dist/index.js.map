{
  "version": 3,
  "sources": ["../src/index.ts", "../src/errors/ReliableFetchChaosError.ts", "../src/utils/index.ts", "../src/fetch/fetchChaos.ts", "../src/fetch/fetchTimeout.ts", "../src/fetch/fetchHedge.ts", "../src/fetch/fetchRetry.ts"],
  "sourcesContent": ["import {\n    ChaosConfig,\n    HedgeConfig,\n    ReliableRequestInfo,\n    ReliableRequestInit,\n    RetryConfig,\n    TimeoutConfig,\n} from './types'\nimport { fetchChaos, fetchHedge, fetchRetry, fetchTimeout } from './fetch'\nimport EventEmitter from 'events'\nimport { EventName, EventListenerFunction } from './types'\n\nexport class ReliableFetch {\n    constructor(\n        private input: ReliableRequestInfo,\n        private init: ReliableRequestInit = {}\n    ) {\n        this.init.eventEmitter = new EventEmitter()\n    }\n\n    /**\n     * Listen for a specific lifecycle event by event name.\n     *\n     * @param {EventName} eventName - unique identifier for a lifecycle event\n     * @param {EventListenerFunction} listener - callback function for when the lifecycle event is emitted\n     */\n    on(eventName: EventName, listener: EventListenerFunction): ReliableFetch {\n        const { eventEmitter } = this.init\n        if (eventEmitter) {\n            eventEmitter.on(eventName, listener)\n        }\n        return this\n    }\n\n    /**\n     * The request will be aborted with an `AbortError` if it does not settle\n     * within the configured timeout.\n     *\n     * @param {TimeoutConfig} config\n     * @param {number} config.timeout - milliseconds (default: 10000)\n     */\n    timeout(config?: Partial<TimeoutConfig>): Promise<Response> {\n        return fetchTimeout(this.input, { ...this.init, ...config })\n    }\n\n    /**\n     * The initial request will be aborted if it does not settle within the\n     * configured timeout and hedged with another request (e.g. set\n     * `config.timeout` to the P95 response time to hedge 5% of requests).\n     *\n     * @param {HedgeConfig} config\n     * @param {number} config.timeout - milliseconds (default: 10000)\n     *\n     * @see https://courses.cs.duke.edu//cps296.4/fall13/838-CloudPapers/dean_longtail.pdf\n     */\n    hedge(config?: Partial<HedgeConfig>): Promise<Response> {\n        return fetchHedge(this.input, { ...this.init, ...config })\n    }\n\n    /**\n     * The request will randomly fail with a `ReliableFetchChaosError` based on\n     * the configured rate (e.g. set `config.rate` to `0.1` for ~10% of requests\n     * to fail).\n     *\n     * @param {ChaosConfig} config\n     * @param {number} config.rate - number between 0 and 1 representing the percentage of fetch calls to fail (default: 1)\n     */\n    chaos(config?: Partial<ChaosConfig>): Promise<Response> {\n        return fetchChaos(this.input, { ...this.init, ...config })\n    }\n\n    /**\n     * The request will be retried based on the configuration.\n     *\n     * @param {RetryConfig} config\n     * @param {number} config.attempts - number of times to attempt (default: 1)\n     * @param {number} config.maxAttempts - maximum number of times to attempt (default: 10)\n     * @param {number} config.delay - delay between attempts in milliseconds (default: 100)\n     * @param {number} config.maxDelay - maximum delay between attempts in milliseconds (default: 10000)\n     * @param {Backoff} config.backoff - constant, exponential or fibonacci (default: constant)\n     * @param {Jitter} config.jitter - none, naive, equal or full (default: none)\n     *\n     * @see https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n     */\n    retry(config?: Partial<RetryConfig>): Promise<Response> {\n        return fetchRetry(this.input, { ...this.init, ...config })\n    }\n}\n\nconst reliableFetch = (\n    url: ReliableRequestInfo,\n    init?: ReliableRequestInit\n): ReliableFetch => new ReliableFetch(url, init)\n\nexport default reliableFetch\nexport * from './errors'\nexport * from './fetch'\nexport * from './types'\n", "export default class ReliableFetchChaosError extends Error {}\n", "import crypto from 'crypto'\n\nexport const randomNumber = (): number => {\n    const max = 100\n    return crypto.randomInt(0, max) / max\n}\n\nexport const randomNumberBetween = (min: number, max: number): number => {\n    return randomNumber() * (max - min) + min\n}\n\nexport const setTimeoutWithCancel = (\n    callback: VoidFunction,\n    ms?: number\n): { id: NodeJS.Timeout; cancel: VoidFunction } => {\n    const id = setTimeout(callback, ms)\n    const cancel = () => clearTimeout(id)\n\n    return {\n        id,\n        cancel,\n    }\n}\n", "import { ChaosConfig, ReliableFetchFunction } from '../types'\nimport { ReliableFetchChaosError } from '../errors'\nimport { randomNumber } from '../utils'\n\nconst fetchChaos: ReliableFetchFunction = async (input, init) => {\n    const config: ChaosConfig = {\n        rate: 1 - (init?.rate ?? 0),\n    }\n    const randomNum = randomNumber()\n\n    if (config.rate < 0 || config.rate > 1) {\n        throw new RangeError('rate: should be between 0 and 1')\n    } else if (randomNum > config.rate) {\n        init?.eventEmitter?.emit('chaos')\n        throw new ReliableFetchChaosError(\n            `${randomNum.toFixed(2)} > ${config.rate} `\n        )\n    }\n\n    return fetch(input, init)\n}\n\nexport default fetchChaos\n", "import { ReliableFetchFunction, TimeoutConfig } from '../types'\nimport { setTimeoutWithCancel } from '../utils'\n\nconst fetchTimeout: ReliableFetchFunction = async (input, init) => {\n    const config: TimeoutConfig = {\n        timeout: init?.timeout ?? 10000,\n    }\n    const controller = new AbortController()\n    const { cancel } = setTimeoutWithCancel(() => {\n        controller.abort()\n        init?.eventEmitter?.emit('timeout')\n    }, config.timeout)\n\n    return fetch(input, { ...init, signal: controller.signal }).finally(cancel)\n}\n\nexport default fetchTimeout\n", "import { HedgeConfig, ReliableFetchFunction } from '../types'\nimport fetchTimeout from './fetchTimeout'\n\nconst fetchHedge: ReliableFetchFunction = async (input, init) => {\n    const config: HedgeConfig = {\n        timeout: init?.timeout ?? 10000,\n    }\n    let response: Response\n\n    try {\n        response = await fetchTimeout(input, { ...init, ...config })\n    } catch (error) {\n        if (error instanceof Error) {\n            if (error.name !== 'AbortError') {\n                throw error\n            }\n        }\n        init?.eventEmitter?.emit('hedge')\n        response = await fetch(input, init)\n    }\n\n    return response\n}\n\nexport default fetchHedge\n", "import { ReliableFetchFunction, RetryConfig } from '../types'\nimport { setTimeout } from 'timers/promises'\nimport { randomNumberBetween } from '../utils'\n\nconst fetchRetry: ReliableFetchFunction = async (input, init) => {\n    const config: RetryConfig = {\n        delay: init?.delay ?? 100,\n        maxDelay: init?.maxDelay ?? 10000,\n        attempts: init?.attempts ?? 1,\n        maxAttempts: init?.maxAttempts ?? 10,\n        backoff: init?.backoff ?? 'constant',\n        jitter: init?.jitter ?? 'none',\n    }\n    const errors = []\n    const delays: number[] = []\n    const retries = Math.min(config.attempts, config.maxAttempts)\n\n    try {\n        return await fetch(input, init)\n    } catch (error) {\n        errors.push(error)\n    }\n\n    for (let i = 0; i < retries; i++) {\n        const attempt = i + 1\n        const delay = Math.min(config.delay, config.maxDelay)\n\n        delays.push(delay)\n        init?.eventEmitter?.emit('retry', i + 1, delay)\n\n        try {\n            return await fetch(input, init)\n        } catch (error) {\n            errors.push(error)\n        }\n\n        await setTimeout(delay)\n\n        switch (config.backoff) {\n            case 'exponential':\n                config.delay = Math.pow(2, attempt) * delay\n                break\n            case 'fibonacci':\n                if (delays.length > 1) {\n                    config.delay =\n                        delays[delays.length - 2] + delays[delays.length - 1]\n                }\n                break\n        }\n\n        switch (config.jitter) {\n            case 'naive':\n                config.delay += randomNumberBetween(0, delay * 0.2)\n                break\n            case 'equal':\n                config.delay =\n                    config.delay / 2 + randomNumberBetween(0, config.delay / 2)\n                break\n            case 'full':\n                config.delay = randomNumberBetween(0, config.delay)\n                break\n        }\n    }\n\n    throw errors.at(-1)\n}\n\nexport default fetchRetry\n"],
  "mappings": "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",
  "names": ["src_exports", "__export", "ReliableFetch", "ReliableFetchChaosError", "src_default", "fetchChaos_default", "fetchHedge_default", "fetchRetry_default", "fetchTimeout_default", "__toCommonJS", "ReliableFetchChaosError", "import_crypto", "randomNumber", "crypto", "randomNumberBetween", "min", "max", "setTimeoutWithCancel", "callback", "ms", "id", "fetchChaos", "input", "init", "config", "randomNum", "randomNumber", "ReliableFetchChaosError", "fetchChaos_default", "fetchTimeout", "input", "init", "config", "controller", "cancel", "setTimeoutWithCancel", "fetchTimeout_default", "fetchHedge", "input", "init", "config", "response", "fetchTimeout_default", "error", "fetchHedge_default", "import_promises", "fetchRetry", "input", "init", "config", "errors", "delays", "retries", "error", "i", "attempt", "delay", "randomNumberBetween", "fetchRetry_default", "import_events", "ReliableFetch", "input", "init", "EventEmitter", "eventName", "listener", "eventEmitter", "config", "fetchTimeout_default", "fetchHedge_default", "fetchChaos_default", "fetchRetry_default", "reliableFetch", "url", "src_default"]
}
